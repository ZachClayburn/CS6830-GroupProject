/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package FinalProject;

import FinalProject.ast.helpers.CompilationUnitHelper;
import FinalProject.ast.helpers.LineASTHelper;
import FinalProject.fault.localizer.Line;
import FinalProject.fault.localizer.oracle.OracleFaultLocalizer;
import FinalProject.fault.localizer.tarantula.TarantulaFaultLocalizer;
import FinalProject.files.SourceSet;
import FinalProject.patcher.FixTemplates;
import FinalProject.patcher.IFixTemplate;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.stmt.Statement;
import net.sourceforge.argparse4j.ArgumentParsers;
import net.sourceforge.argparse4j.impl.Arguments;
import net.sourceforge.argparse4j.inf.ArgumentParserException;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;


public class App implements Closeable {
    final CommandRunner commandRunner;
    final File simpleModifiedFile;
    final File projectRootDirectory;
    final TarantulaFaultLocalizer tarantulaFaultLocalizer;
    final SourceSet sourceSet;
    String testName = null;
    List<IFixTemplate> fixTemplates = FixTemplates.getPatches();

    App(File projectRoot) throws IOException {
        commandRunner = new CommandRunner(projectRoot);
        this.projectRootDirectory = projectRoot;
        simpleModifiedFile = Paths.get(projectRoot.toString(), "lib", "src", "main", "java", "testApplication", "simple", "Simple.java")
                            .toFile();
        tarantulaFaultLocalizer = new TarantulaFaultLocalizer(projectRoot, commandRunner);

        commandRunner.runJar(); // Ensure that the jars exist for the symbol solver to use
        SourceSet.setupSymbolSolver(projectRoot.toPath());
        sourceSet = SourceSet.fromProjectDirectory(projectRoot.toPath());
    }

    List<Path> getSimpleTestPaths() {
        List<Path> testPaths = new ArrayList<>();
        try (Stream<Path> stream = Files.walk(projectRootDirectory.toPath())) {
            List<Path> filePaths = stream.collect(Collectors.toList());
            for (Path filePath : filePaths) {
                if (filePath.toString().contains(".java") &&
                        filePath.toString().contains("Test") &&
                        filePath.toString().contains("Simple")) {
                    testPaths.add(filePath);
                }
            }
        } catch (IOException ioException) {
            ioException.printStackTrace();
            System.exit(1);
        }
        return testPaths;
    }

    void printPatch(long lineNumber, List<Node> nodes, String testClassName) {
        System.out.printf("To fix %s, replace line %d with:\n", testClassName, lineNumber);
        System.out.println(nodes);
    }

    void run() {
        commandRunner.runBuild();
        try {
            for (Path path : getSimpleTestPaths()) {
                File file = path.toFile();
                Line line = OracleFaultLocalizer.localizeFaults(file);
                boolean foundAFix = false;

                for (IFixTemplate template : fixTemplates) {
                    CompilationUnit cu = CompilationUnitHelper.createCompilationUnit(simpleModifiedFile.getAbsolutePath());
                    if (cu == null) {
                        System.err.println("Could not create compilationunit for source file");
                        System.exit(1);
                    }
                    String testClassName = file.getName().replace(".java", "");
                    var node = LineASTHelper.getLineAST(cu, (int)line.lineNumber);

                    if (node == null) {
                        System.err.println("Could not find AST for node for line number " + (int)line.lineNumber);
                        System.exit(1);
                    }

                    if (!template.checkNode(node)) continue;
                    var changedNodes = template.applyPatch(node);
                    int numberLinesToDelete = node.getRange().get().getLineCount();
                    LineASTHelper.writeASTLinesToFile(simpleModifiedFile, changedNodes, (long)line.lineNumber, numberLinesToDelete);

                    if (commandRunner.runBuild() && commandRunner.runSpecificTest(testClassName)) {
                        printPatch((int)line.lineNumber, changedNodes, testClassName);
                        sourceSet.restoreToDefault();
                        foundAFix = true;
                        break;
                    }
                    sourceSet.restoreToDefault();
                }

                if (!foundAFix) {
                    System.out.println("Could not fix error for file " + file.getAbsolutePath());
                }
            }
        } catch (IOException ioException) {
            ioException.printStackTrace();
            System.exit(1);
        }
//        try {
//            var x = LineASTHelper.getLineAST(new File(""), 34);
//            ArrayList<Statement> statements = new ArrayList<>();
//            statements.add(StaticJavaParser.parseStatement("c = a + b;"));
//            statements.add(StaticJavaParser.parseStatement("String s = \"test\";"));
//            LineASTHelper.writeASTLinesToFile(new File(""), statements, 34);
//            System.out.println(x.toString());
//        } catch (IOException ioException) {
//            ioException.printStackTrace();
//            System.exit(1);
//        }
    }

//    boolean tryNode(Node node, File fileName) {
//        for (IFixTemplate template : fixTemplates) {
//            var fix = template.generateFixes(node, fileName);
//            if (fix == null) continue;
//            try {
//                fix.writeBackFile();
//            } catch (IOException e) {
//                throw new RuntimeException(e);
//            }
//            // build failed, not a valid patch
//            if (!commandRunner.runBuild()) continue;
//            var testResults = testName == null ? commandRunner.runTests() : commandRunner.runSpecificTest(testName);
//            if (testResults) return true;
//        }
//        return false;
//    }

//    void run(File filePath) throws FileNotFoundException {
//        var optFixFile = sourceSet.get(filePath);
//        if (optFixFile.isEmpty()) {
//            throw new FileNotFoundException("Cannot find " + filePath);
//        }
//        var fixFile = optFixFile.get();
//        var fileContents = fixFile.getFileContents();
//        fileContents.stream().map(node -> tryNode(node, filePath)).filter(n -> n).findFirst();
//    }

    @Override
    public void close() throws IOException {
        sourceSet.close();
    }

    public void setTestName(String testName) {
        this.testName = testName;
    }

    public static void main(String[] args) {
        var parser = ArgumentParsers.newFor("Par").build().description("Automatic program repair");
        parser.addArgument("ProjectDir")
              .required(true)
              .type(Arguments.fileType().verifyIsDirectory())
              .help("Root directory of the project to apply automatic an automatic repair")
              .metavar("<Project root>");
        parser.addArgument("--fix-file").type(Arguments.fileType().verifyIsFile());
        parser.addArgument("--test-name");
        File testProjectDir = null;
        String testName = null;
        try {
            var res = parser.parseArgs(args);
            testProjectDir = res.get("ProjectDir");
            testName = res.get("test_name");
        } catch (ArgumentParserException e) {
            parser.handleError(e);
            System.exit(-1);
        }

        try (var app = new App(testProjectDir)) {
            app.setTestName(testName);
            app.run();
        } catch (IOException e) {
            e.printStackTrace();
            System.exit(1);
        }

    }

}
